#!/usr/bin/env python3
"""
Visualize sunset time for a given French department
from the Parquet files generated by ``run_solar_parquet.py``.

Example usage
-------------

    python -m src.viz.visualize_sunset_map --dept 38 --date 2025-12-04
"""

from __future__ import annotations

import argparse
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, Tuple

import numpy as np
import pyarrow.parquet as pq
import geopandas as gpd
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter
from mpl_toolkits.axes_grid1 import make_axes_locatable

from ..config import PROJECT_ROOT, DEPT_SHAPEFILE


PARQUET_DIR = PROJECT_ROOT / "data" / "parquet"


def guess_dept_code_column(gdf: gpd.GeoDataFrame, target_code: str) -> str:
    """
    Try to infer the column that contains the department code.

    This is intentionally permissive so that different shapefiles
    with slightly different naming conventions still work.
    """
    candidates = [
        "code_dept",
        "code_dep",
        "code_dep",
        "dep",
        "department",
        "departemen",
        "insee_dep",
        "code_insee",
    ]

    # First try a list of common/expected column names
    lower_cols = {c.lower(): c for c in gdf.columns}
    for cand in candidates:
        if cand in lower_cols:
            col = lower_cols[cand]
            values = set(map(str, gdf[col]))
            if target_code in values:
                return col

    # Otherwise, scan all object / string columns
    for col in gdf.columns:
        if gdf[col].dtype == object:
            values = set(map(str, gdf[col]))
            if target_code in values:
                return col

    raise ValueError(
        f"Could not find a department-code column containing '{target_code}'. "
        f"Available columns: {list(gdf.columns)}"
    )


def load_sunset_grid(
    dept_code: str, target_date: datetime
) -> Tuple[np.ndarray, Dict]:
    """
    Load the 2D grid of sunset time for one department and date.

    The values are minutes after midnight. Returns ``(grid, metadata)`` where
    ``grid`` is a 2D ``(height, width)`` NumPy array and ``metadata`` contains
    raster dimensions and georeferencing information.
    """
    partition_dir = PARQUET_DIR / f"dept={dept_code}"
    parquet_file = partition_dir / "data.parquet"
    metadata_file = partition_dir / "metadata.json"

    if not parquet_file.exists():
        raise FileNotFoundError(f"Parquet file not found: {parquet_file}")
    if not metadata_file.exists():
        raise FileNotFoundError(f"Metadata JSON file not found: {metadata_file}")

    with metadata_file.open("r", encoding="utf-8") as f:
        metadata = json.load(f)

    width = int(metadata["width"])
    height = int(metadata["height"])

    # Day-of-year index (1–365 / 366)
    day_of_year = target_date.timetuple().tm_yday

    # Read only the row for the requested day
    table = pq.read_table(
        parquet_file,
        columns=["day", "sunset"],
        filters=[("day", "=", day_of_year)],
    )

    if table.num_rows == 0:
        raise ValueError(
            f"No data for day {day_of_year} (date {target_date.date()}) "
            f"in {parquet_file}"
        )

    df = table.to_pandas()
    # There should be exactly one row for this day
    row = df.iloc[0]
    sunset = np.asarray(row["sunset"], dtype=np.int16)

    if sunset.size != width * height:
        raise ValueError(
            f"Inconsistent array size: expected {width * height}, got {sunset.size}"
        )

    # Reshape to 2D (row-major: height x width)
    grid = sunset.reshape((height, width)).astype(float)
    # -1 means “no sunset” (e.g. high-latitude summer) => convert to NaN
    grid[grid < 0] = np.nan

    return grid, metadata


def plot_sunset_map(
    dept_code: str,
    target_date: datetime,
    output_path: Path,
) -> None:
    """
    Create a 2D map of sunset times for a department with its boundary
    and a few reference cities drawn on top.
    """
    grid, metadata = load_sunset_grid(dept_code, target_date)

    width = int(metadata["width"])
    height = int(metadata["height"])
    gt = metadata["transform"]

    # GDAL-style GeoTransform: [origin_x, pixel_w, 0, origin_y, 0, pixel_h]
    origin_x, pixel_w, _, origin_y, _, pixel_h = gt

    # Extent for ``imshow``: [xmin, xmax, ymin, ymax]
    xmin = origin_x
    xmax = origin_x + pixel_w * width
    ymax = origin_y
    ymin = origin_y + pixel_h * height  # pixel_h est négatif

    # Load department polygons
    depts = gpd.read_file(DEPT_SHAPEFILE)
    code_col = guess_dept_code_column(depts, dept_code)
    dept = depts[depts[code_col].astype(str) == dept_code]
    if dept.empty:
        raise ValueError(f"Département {dept_code} introuvable dans {DEPT_SHAPEFILE}")

    # A few main cities in Isère (dept 38), approximate (lon, lat) in WGS84.
    # You can safely extend or generalize this dictionary if needed.
    cities: Dict[str, Tuple[float, float]] = {
        "Grenoble": (5.7245, 45.1885),
        "Voiron": (5.5925, 45.3667),
        "Vienne": (4.8714, 45.525),
        "Bourgoin-Jallieu": (5.2728, 45.5861),
    }

    fig, ax = plt.subplots(figsize=(8, 8))

    im = ax.imshow(
        grid,
        origin="upper",
        extent=[xmin, xmax, ymin, ymax],
        cmap="plasma",
    )

    # Department outline
    dept.boundary.plot(ax=ax, edgecolor="black", linewidth=1.2)

    # Cities
    for name, (lon, lat) in cities.items():
        ax.scatter(lon, lat, color="white", edgecolor="black", s=40, zorder=5)
        ax.text(
            lon + 0.03,
            lat + 0.03,
            name,
            fontsize=8,
            color="white",
            path_effects=None,
        )

    # Extract and print the exact sunset time at Grenoble (if inside raster)
    if "Grenoble" in cities:
        g_lon, g_lat = cities["Grenoble"]
        # Convert (lon, lat) coordinates -> raster grid indices (col, row)
        # x = origin_x + col * pixel_w
        # y = origin_y + row * pixel_h
        col = int(round((g_lon - origin_x) / pixel_w))
        row = int(round((g_lat - origin_y) / pixel_h))

        if 0 <= row < height and 0 <= col < width:
            value_min = grid[row, col]
            if not np.isnan(value_min):
                m = int(round(value_min))
                h = m // 60
                mn = m % 60
                print(
                    f"Sunset time in Grenoble on {target_date.date()}: "
                    f"{h:02d}:{mn:02d} (minutes after midnight: {m})"
                )
        else:
            print("Warning: Grenoble lies outside the computed raster extent.")

    # Colorbar with HH:MM tick labels (minutes -> clock time)
    def minutes_to_hhmm(x, _pos=None):
        if np.isnan(x):
            return ""
        m = int(round(x))
        h = m // 60
        mn = m % 60
        return f"{h:02d}:{mn:02d}"

    # Use axes_grid1 so the colorbar has the same height as the map frame.
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.1)
    cbar = fig.colorbar(im, cax=cax, format=FuncFormatter(minutes_to_hhmm))
    cbar.set_label("Sunset time (local)")

    ax.set_xlabel("Longitude")
    ax.set_ylabel("Latitude")
    ax.set_title(f"Department {dept_code} - {target_date.strftime('%d/%m/%Y')}")

    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)

    output_path.parent.mkdir(parents=True, exist_ok=True)
    fig.tight_layout()
    fig.savefig(output_path, dpi=200)
    plt.close(fig)


def parse_args() -> argparse.Namespace:
    """Parse command-line arguments for the sunset map CLI."""
    parser = argparse.ArgumentParser(
        description="Generate a sunset-time map for a French department."
    )
    parser.add_argument(
        "--dept",
        type=str,
        default="38",
        help="Department code (default: 38).",
    )
    parser.add_argument(
        "--date",
        type=str,
        default="2025-12-04",
        help="Date in YYYY-MM-DD format (default: 2025-12-04).",
    )
    parser.add_argument(
        "--output",
        type=str,
        default=None,
        help="Output PNG path (default: data/results/...).",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    target_date = datetime.strptime(args.date, "%Y-%m-%d")
    dept_code = args.dept

    if args.output is not None:
        output_path = Path(args.output)
    else:
        output_dir = PROJECT_ROOT / "data" / "results"
        output_filename = f"sunset_dept{dept_code}_{target_date.date()}.png"
        output_path = output_dir / output_filename

    print(
        f"Generating sunset map for department {dept_code} "
        f"on {target_date.date()} -> {output_path}"
    )
    plot_sunset_map(dept_code, target_date, output_path)
    print("Done.")


if __name__ == "__main__":
    main()


